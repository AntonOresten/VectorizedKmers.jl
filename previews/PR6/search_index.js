var documenterSearchIndex = {"docs":
[{"location":"kmer_count/","page":"The KmerCount type","title":"The KmerCount type","text":"CurrentModule = VectorizedKmers\nDocTestSetup = quote\n    using VectorizedKmers\nend","category":"page"},{"location":"kmer_count/#The-KmerCount-type","page":"The KmerCount type","title":"The KmerCount type","text":"","category":"section"},{"location":"kmer_count/","page":"The KmerCount type","title":"The KmerCount type","text":"The KmerCount type has four type parameters, but you only really need to care about the first two: A, the alphabet size, and K, the K-mer length. So, to count the 6-mers of a DNA sequence, you would use KmerCount{4, 6}. For each of these K-mer counts, memory for a vector of size A^K is allocated, unless a vector type like SparseVector is used. This brings us to the two other type parameters: T, which is the vector element type, and V, which is the type of the actual vector.","category":"page"},{"location":"kmer_count/","page":"The KmerCount type","title":"The KmerCount type","text":"Let's see it in action:","category":"page"},{"location":"kmer_count/","page":"The KmerCount type","title":"The KmerCount type","text":"julia> kc = KmerCount{4, 2}(); # creates a Vector{Int} of zeros with length 4^2\n\njulia> using BioSequences # a weak dependency that lets us count kmers of LongDNA{4} sequences\n\njulia> count_kmers!(kc, dna\"ACGT\"); # AC is 0001, CG is 0110, GT is 1011\n\njulia> @show kc; # indices offset by 1. thanks julia...\nkc = [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n\njulia> count_kmers!(kc, dna\"ACGT\"); # count again\n\njulia> @show kc; # the vector gets reset to zeros before counting again\nkc = [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n\njulia> count_kmers!(kc, dna\"ACGT\", reset=false); # avoid reset with reset=false\n\njulia> @show kc; # look! we counted 2-mers of ACGT twice\nkc = [0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VectorizedKmers\nDocTestSetup = quote\n    using VectorizedKmers\nend","category":"page"},{"location":"#VectorizedKmers","page":"Home","title":"VectorizedKmers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"VectorizedKmers.jl is a Julia package for fast k-mer counting of biological sequences. The core idea is that k-mers with an alphabet size A are essentially integers in base A, and can be used as indices in a vector of size A^k to count the corresponding k-mers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The KmerCount type is a wrapper for AbstractVector, which means that these vector k-mer counts are not limited to Julia's Base.Vector type; other kinds of vectors can be used as well, such as CUDA.CuVector, SparseArrays.SparseVector or even matrix views. To efficiently group k-mer counts together, the KmerCountVector stores them in a matrix as rows or columns. It can wrap any AbstractMatrix, such as Matrix or CuMatrix, and accessing its elements by index returns a KmerCount wrapped around a view of a row or column of the original matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This data structure can be used to quickly approximate distances between sequences. Most notably, the squared Euclidean distance was used to estimate edit distance in this paper. The dot product has also proven to be a useful metric for comparing correlation between sequences.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install VectorizedKmers in your environment from the Julia REPL by entering pkg mode with ] and then running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add VectorizedKmers","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [VectorizedKmers]","category":"page"},{"location":"#VectorizedKmers.AbstractKmerCount","page":"Home","title":"VectorizedKmers.AbstractKmerCount","text":"AbstractKmerCount{A, K, T <: Real, V <: AbstractVector{T}}\n\nAbstract type for K-mer counts. A is the alphabet size, K is the K-mer size, and T is the element type of the underlying counts field, which in turn has type V{T}.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizedKmers.AbstractKmerCountVector","page":"Home","title":"VectorizedKmers.AbstractKmerCountVector","text":"AbstractKmerCountVector{A, K, T <: Real, M <: AbstractMatrix{T}} <: AbstractVector{KmerCount{A, K, T, V} where {V <: AbstractVector{T}}}\n\nYup... that's indeed an abomination of a type. A container for K-mer counts, where K-mer counts are stored together as rows or columns in a matrix. A is the alphabet size, K is the K-mer size, T is the element type of the counts, and M is the type of the matrix in which the K-mer counts are stored.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizedKmers.KmerCount","page":"Home","title":"VectorizedKmers.KmerCount","text":"KmerCount{A, K, T, V} <: AbstractKmerCount{A, K, T, V}\n\nA concrete type for K-mer counts with vector type V and element type T.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizedKmers.KmerCountColumns","page":"Home","title":"VectorizedKmers.KmerCountColumns","text":"KmerCountColumns{A, K, T, M} <: AbstractKmerCountVector{A, K, T, M}\n\nA container for K-mer counts, where K-mer counts are stored together as columns in a matrix. This is more efficient than storing K-mer counts as rows in a matrix, since the elements in a column are contiguous in memory.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizedKmers.KmerCountRows","page":"Home","title":"VectorizedKmers.KmerCountRows","text":"KmerCountRows{A, K, T, M} <: AbstractKmerCountVector{A, K, T, M}\n\nA container for K-mer counts, where K-mer counts are stored together as rows in a matrix. This is not as efficient as storing K-mer counts as columns in a matrix, since the elements in a row are not contiguous in memory.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizedKmers.count_kmers!-Union{Tuple{T}, Tuple{K}, Tuple{A}, Tuple{KmerCount{A, K, T}, Vector{<:Integer}}} where {A, K, T}","page":"Home","title":"VectorizedKmers.count_kmers!","text":"count_kmers!(kmer_count, kmers; reset=true)\n\nMutate the counts vector in kmer_count by counting K-mers in kmers. The K-mers in kmers must be represented as integers between 0 and length(kmer_count) - 1.\n\nIf reset is true, the counts vector will be zero-ed before counting.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedKmers.count_kmers-Union{Tuple{T}, Tuple{K}, Tuple{A}, Tuple{KmerCount{A, K, T}, Vector{<:Integer}}} where {A, K, T}","page":"Home","title":"VectorizedKmers.count_kmers","text":"count_kmers(KmerCount{A, K, T}, kmers; zeros_func=zeros, reset=true)\n\nCreate a new A^K sized vector using zeros_func and count the K-mers in kmers. The K-mers in kmers must be represented as integers between 0 and length(kmer_count) - 1.\n\nIf reset is true, the counts vector will be zero-ed before counting.\n\n\n\n\n\n","category":"method"}]
}
