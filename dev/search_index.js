var documenterSearchIndex = {"docs":
[{"location":"references/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"references/","page":"API Reference","title":"API Reference","text":"Modules = [VectorizedKmers]","category":"page"},{"location":"references/#VectorizedKmers.AbstractKmerArray","page":"API Reference","title":"VectorizedKmers.AbstractKmerArray","text":"AbstractKmerArray{N, S, K, T, A <: AbstractArray{T, N}} <: AbstractArray{T, N}\n\nAbstract type representing K-mer count in N-dimensional arrays. This type serves as the foundation for various concrete K-mer count structures.\n\nType Parameters\n\nN: Dimensionality of the array\nS: Alphabet size\nK: K-mer size\nT: Element type\nA: Array type, subtype of AbstractArray{T, N}\n\n\n\n\n\n","category":"type"},{"location":"references/#VectorizedKmers.KmerVector","page":"API Reference","title":"VectorizedKmers.KmerVector","text":"KmerVector{S, K, T, V} <: AbstractKmerVector{S, K, T, V}\n\nA is the alphabet size, K is the K-mer size, and T is the element type of the underlying values field, which in turn has type V.\n\n\n\n\n\n","category":"type"},{"location":"references/#VectorizedKmers.KmerVectors","page":"API Reference","title":"VectorizedKmers.KmerVectors","text":"KmerVectors\n\nA container for K-mer vectors, where the values are stored together as columns or rows in a matrix.\n\nD is the dimension of the vectors (i.e. 1 for column-vectors, 2 for row-vectors). S is the alphabet size, k is the K-mer length, and T is the element type of the underlying values field, which in turn has type M.\n\n\n\n\n\n","category":"type"},{"location":"references/#VectorizedKmers.count_kmers","page":"API Reference","title":"VectorizedKmers.count_kmers","text":"count_kmers(sequence, S, k; T=Int, zeros=zeros)\n\nCreates a new S^K-sized vector using the supplied zeros function and counts the K-mers in sequence. Since S is the alphabet, and the elements in sequence are integers, the maximum value in sequence must be less than S\n\n\n\n\n\n","category":"function"},{"location":"references/#VectorizedKmers.count_kmers!","page":"API Reference","title":"VectorizedKmers.count_kmers!","text":"count_kmers!(kmer_vector, sequence; reset=true)\n\nMutates kmer_vector.\n\nIf reset is true, the array will be zero-ed before counting.\n\n\n\n\n\n","category":"function"},{"location":"kmer_int_repr/#Integer-representation-of-K-mers","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"","category":"section"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"This package relies on representing K-mers as integers for indexing. This page goes over how that works exactly.","category":"page"},{"location":"kmer_int_repr/#DNA-sequences","page":"Integer representation of K-mers","title":"DNA sequences","text":"","category":"section"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"For DNA, each non-ambiguous nucleotide is assigned a number between 0 and 3:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"Nucleotide Base-4 Base-2\nA 0 00\nC 1 01\nG 2 10\nT 3 11","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"note: Note\nAny ordering works, but this is the one used by BioSequences.jl. It also has some nice properties, like being in alphabetical order, and that XOR-ing a base with 3 gives you its complement.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"We could theoretically convert any DNA sequence to an integer, but 64-bit unsigned integers limit us to 32-mers.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"Consider the DNA sequence GATTACA. If we convert it to an integer using the table above, we get 2033010_4 = 10001111000100_2 = 9156_10, so the integer value of GATTACA is 9156. Since Julia uses 1-based indexing, we would add 1 to this value to get the index of GATTACA in the vector.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"Writing a function for this might look like the following:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"julia> const DNA_ENCODING_VECTOR = zeros(UInt, 127);\n\njulia> for (i, char) in enumerate(\"ACGT\")\n           DNA_ENCODING_VECTOR[char % Int8] = i - 1\n       end;\n\njulia> function kmer_to_int(kmer::String)\n           kmer_int = zero(UInt)\n           for char in kmer\n               kmer_int = (kmer_int << 2) | DNA_ENCODING_VECTOR[char % Int8]\n           end\n           return kmer_int\n       end;\n\njulia> f(k;i=0)=[i=4i|(c%Int-1-(c=='C'))&3 for c=k][end]; # or if you're into code golf:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"note: Note\nConsider using types like BioSequences.LongDNA{4} instead of String, as strings are not optimized for performance.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"This function would not be very efficient in a practical setting (even though we're using super cool bit manipulation), since we're convert each K-mer individually, instead of having some kind of sliding window. Moreover, the function takes the K-mer in the form of a String, which is not ideal. The function should work as intended, though. Let's test it:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"julia> kmer_to_int(\"GATTACA\")\n9156\n\njulia> f(\"GATTACA\")\n9156","category":"page"},{"location":"kmer_int_repr/#Amino-acid-sequences","page":"Integer representation of K-mers","title":"Amino acid sequences","text":"","category":"section"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"Amino acid sequences are a little more difficult to deal with since we have multiple reading frames, and since the alphabet is much larger, the vectors grow in size much quicker as k increases. However, we can still represent them as integers, like we did with DNA in the form of Strings, just without the fancy-looking bit-manipulation.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"BioSequences.jl has 28 amino acids in its AminoAcidAlphabet, so we can represent each amino acid as an integer between 0 and 27.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"julia> using BioSequences\n\njulia> length(AminoAcidAlphabet())\n28","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"The AminoAcidAlphabet consists of amino acids with 8 bits each, so we can reinterpret them as 8-bit integers.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"julia> reinterpret.(Int8, [AA_A, AA_M, AA_I, AA_N, AA_O])\n5-element Vector{Int8}:\n  0\n 12\n  9\n  2\n 20","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"Let's say we want to convert the amino acid sequence AMINO to an integer. As seen above, the amino acids in the sequence have values of 0, 12, 9, 2, and 20 respectively. Thus, the integer value of the K-mer should be:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"$","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"0 \\cdot 28^4 + 12 \\cdot 28^3 + 9 \\cdot 28^2 + 2 \\cdot 28^1 + 20 \\cdot 28^0 = 270556 $","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"We can write a function for this:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"julia> function kmer_to_int(kmer::LongAA)\n           kmer_int = zero(UInt)\n           for aa in kmer\n               kmer_int = kmer_int * 28 + reinterpret(UInt8, aa)\n           end\n           kmer_int\n       end","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"To test it, we can use the aa\"...\" string macro to create a LongAA instance:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of K-mers","title":"Integer representation of K-mers","text":"julia> kmer_to_int(aa\"AMINO\")\n270556","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"CurrentModule = VectorizedKmers\nDocTestSetup = quote\n    using VectorizedKmers\nend","category":"page"},{"location":"kmer_count_matrix/#Matrices-of-K-mer-counts","page":"Matrices of K-mers counts","title":"Matrices of K-mer counts","text":"","category":"section"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"How can we efficiently store multiple K-mer count vectors of sequences? We could use a regular vector: Base.Vector{<:KmerVector}, but remember that KmerVector can wrap any AbstractVector, including rows/columns of matrices, which means that we can store the K-mer counts of multiple sequences next to each other in a matrix (all k-mer counts will have a size of S^k). This can be done using the KmerColumns and KmerRows types, which wrap AbstractMatrix types, and store the K-mer counts as columns and rows of the matrix, respectively.","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"Let's create an instance of KmerColumns, and configure it for storing the 1-mer counts of three DNA sequences. The alphabet size for DNA is 4, so each KmerVector will have a size of S^k=4^1=4. We'll initialize it with a matrix of zeros:","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"julia> K = 1;\n\njulia> n = 3;\n\njulia> kc = KmerColumns{4, K}(n)\n4×3 KmerColumns{4, 1, Int64, Matrix{Int64}}:\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"We can create a generator of KmerVectors using eachvec, and collect it to get a vector of KmerVectors.","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"julia> collect(VectorizedKmers.eachvec(kc))\n3-element Vector{KmerVector{4, 1, Int64, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}}:\n KmerVector{4, 1, Int64, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}([0, 0, 0, 0])\n KmerVector{4, 1, Int64, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}([0, 0, 0, 0])\n KmerVector{4, 1, Int64, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}([0, 0, 0, 0])","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"Those types sure don't look pretty. Let's break down what's happening here:","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"The matrix can be thought of as three different 1-mer count vectors of length 4, stored in columns.\nEach vector in KmerColumns is a KmerVector wrapped around a view of a column of the underlying matrix, hence the SubArray type.\nWhen collected, the generator becomes a vector of KmerVectors.","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"We can also access each column by index, which gives us a KmerVector wrapped around a view of the corresponding column:","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"julia> kc[1]\n4-element KmerVector{4, 1, Int64, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n 0\n 0\n 0\n 0","category":"page"},{"location":"kmer_count_matrix/#Counting-K-mers-in-matrices","page":"Matrices of K-mers counts","title":"Counting K-mers in matrices","text":"","category":"section"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"Now that we understand how storing K-mer counts in matrices works, we can count K-mers of sequences using a method of count_kmers! that takes a KmerVector and a sequence as input.","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"Here, our KmerColumns instance, which we call kc, is configured to count the 1-mers of DNA. Let's count the 1-mers of the sequence GATTACA in the first column of kc:","category":"page"},{"location":"kmer_count_matrix/","page":"Matrices of K-mers counts","title":"Matrices of K-mers counts","text":"julia> using BioSequences\n\njulia> count_kmers!(kc, [dna\"GATTACA\"])\n4×3 KmerColumns{4, 1, Int64, Matrix{Int64}}:\n 3  0  0\n 1  0  0\n 1  0  0\n 2  0  0\n\njulia> count_kmers!(kc, [dna\"ACGT\", dna\"ATAT\"], offset=1)\n4×3 KmerColumns{4, 1, Int64, Matrix{Int64}}:\n 3  1  2\n 1  1  0\n 1  1  0\n 2  1  2","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"CurrentModule = VectorizedKmers\nDocTestSetup = quote\n    using VectorizedKmers\nend","category":"page"},{"location":"kmer_count_vector/#Vectors-of-K-mer-counts","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"","category":"section"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"The KmerVector type has four type parameters, but you only really need to care about the first two: S, the alphabet size, and k, the K-mer length. So, to count the 6-mers of a DNA sequence, you would use KmerVector{4, 6}. For each of these K-mer counts, memory for a vector of size S^k is allocated, unless a vector type like SparseVector is used. This brings us to the two other type parameters: T, which is the vector element type, and V, which is the type of the actual vector.","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"Let's see it in action! Here we import BioSequences to unlock a method of count_kmers that works on the LongDNA type. In this example, we count the 1-mers of the sequence GATTACA. The result is a KmerVector{4, 1, Int64, Vector{Int64}}, which is a vector of 4 Int64 elements.","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"julia> using BioSequences\n\njulia> kv = count_kmers(dna\"GATTACA\", 1)\n4-element KmerVector{4, 1, Int64, Vector{Int64}}:\n 3\n 1\n 1\n 2","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"We can also change the element type to save memory, at the cost of a smaller maximum count value.","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"julia> count_kmers(dna\"GATTACA\", 1, T=UInt16)\n4-element KmerVector{4, 1, UInt16, Vector{UInt16}}:\n 0x0003\n 0x0001\n 0x0001\n 0x0002","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"note: Note\nBe careful when using element types with fewer bits, such as UInt16. Even though you might not expect any one K-mer to occur more than 65,535 times, some vector operations such as LinearAlgebra.dot and Distances.sqeuclidean will still use UInt16 when summing up terms, which might lead to integer overflow.","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"The count_kmers! function will modify a KmerVector instance in-place. This is useful when you want to count K-mers in a sequence without allocating a new vector.","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"Let's create a KmerVector instance with SparseVector as its vector type. We can do this by passing spzeros to the KmerVector{S, K, T} constructor (it's just zeros by default):","category":"page"},{"location":"kmer_count_vector/","page":"Vectors of K-mer counts","title":"Vectors of K-mer counts","text":"julia> using SparseArrays\n\njulia> kv2 = KmerVector{4, 1}(T=Int64, zeros=spzeros)\n4-element KmerVector{4, 1, Int64, SparseVector{Int64, Int64}}:\n 0\n 0\n 0\n 0\n\njulia> count_kmers!(kv2, dna\"GATTACA\")\n4-element KmerVector{4, 1, Int64, SparseVector{Int64, Int64}}:\n 3\n 1\n 1\n 2\n\njulia> kv == kv2","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VectorizedKmers\nDocTestSetup = quote\n    using VectorizedKmers\nend","category":"page"},{"location":"#VectorizedKmers","page":"Home","title":"VectorizedKmers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Documentation) (Image: Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"VectorizedKmers.jl is a Julia package for fast k-mer counting of biological sequences. The core idea is that k-mers with an alphabet size S are essentially integers in base S, and can be used as indices in a vector of size S^k to count the corresponding k-mers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The KmerVector type is a wrapper for AbstractVector, which means that these vector k-mer counts are not limited to Julia's Base.Vector type; other kinds of vectors can be used as well, such as CUDA.CuVector, SparseArrays.SparseVector or even matrix views.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To efficiently group k-mer counts together, the AbstractKmerMatrix stores them in a matrix as rows or columns. It can wrap any AbstractMatrix, such as Matrix or CuMatrix, and accessing its elements by index returns a KmerVector wrapped around a view of a row or column of the original matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This data structure can be used to quickly approximate distances between sequences. Most notably, the squared Euclidean distance was used to approximate edit distance in this paper. The dot product has also proven to be a useful metric for comparing correlation between sequences.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install VectorizedKmers in your environment from the Julia REPL by entering pkg mode with ] and then running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add VectorizedKmers","category":"page"}]
}
