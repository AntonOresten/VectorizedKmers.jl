var documenterSearchIndex = {"docs":
[{"location":"references/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"references/","page":"API Reference","title":"API Reference","text":"Modules = [VectorizedKmers]","category":"page"},{"location":"references/#VectorizedKmers.KmerArray","page":"API Reference","title":"VectorizedKmers.KmerArray","text":"KmerArray{N, K, T <: Real, A <: AbstractArray{T, K}} <: StaticArray{NTuple{K, N}, T, K}\n\nN is the alphabet size\nK is the K-mer size\nT is the element type\nA is the array type\n\n\n\n\n\n","category":"type"},{"location":"references/#VectorizedKmers.count_kmers!-Union{Tuple{K}, Tuple{N}, Tuple{KmerArray{N, K, T, A} where {T<:Real, A<:AbstractArray{T, K}}, Any}} where {N, K}","page":"API Reference","title":"VectorizedKmers.count_kmers!","text":"count_kmers!(kmer_array, sequence; reset=true)\n\nRequires method axis_index(::KmerArray{N}, ::eltype(sequence)) where N to be defined\n\n\n\n\n\n","category":"method"},{"location":"references/#VectorizedKmers.count_kmers-Union{Tuple{K}, Tuple{N}, Tuple{Any, Val{N}, Val{K}}, Tuple{Any, Val{N}, Val{K}, Type{<:Real}}, Tuple{Any, Val{N}, Val{K}, Type{<:Real}, Any}} where {N, K}","page":"API Reference","title":"VectorizedKmers.count_kmers","text":"count_kmers(sequence, [N,] K, T=Int, zeros=zeros)\n\n\n\n\n\n","category":"method"},{"location":"kmer_int_repr/#Integer-representation-of-K-mers","page":"Integer representation of k-mers","title":"Integer representation of K-mers","text":"","category":"section"},{"location":"kmer_int_repr/","page":"Integer representation of k-mers","title":"Integer representation of k-mers","text":"This package relies on representing K-mers as integers for indexing.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of k-mers","title":"Integer representation of k-mers","text":"For DNA, each non-ambiguous nucleotide is assigned a number between 0 and 3:","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of k-mers","title":"Integer representation of k-mers","text":"Nucleotide Base-4 Base-2\nA 0 00\nC 1 01\nG 2 10\nT 3 11","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of k-mers","title":"Integer representation of k-mers","text":"Any ordering works, but this is the one used by BioSequences.jl. It also has some nice properties, like being in alphabetical order, and that XOR-ing a base with 3 gives you its complement.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of k-mers","title":"Integer representation of k-mers","text":"We could theoretically convert any DNA sequence to an integer, but 64-bit unsigned integers limit us to 32-mers.","category":"page"},{"location":"kmer_int_repr/","page":"Integer representation of k-mers","title":"Integer representation of k-mers","text":"Consider the DNA sequence GATTACA. If we convert it to an integer using the table above, we get 2033010_4 = 10001111000100_2 = 9156_10, so the integer value of GATTACA is 9156. Since Julia uses 1-based indexing, we would add 1 to this value to get the index for the value in a vector associated with GATTACA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VectorizedKmers\nDocTestSetup = quote\n    using VectorizedKmers\nend","category":"page"},{"location":"#VectorizedKmers","page":"Home","title":"VectorizedKmers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Documentation) (Image: Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"VectorizedKmers.jl is a Julia package primarily designed for fast K-mer counting of biological sequences. The core idea is that K-mers with an alphabet size of N are essentially integers in base N, and can be used as indices in a vector of size N^K to count the corresponding K-mers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This data structure can be used to quickly approximate distances between sequences. Notably, the squared Euclidean distance was used to approximate edit distance in this paper. The dot product has also proven to be a useful metric for comparing correlation between sequences.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using VectorizedKmers, BioSequences\n\njulia> kmer_array = count_kmers(dna\"ACCGGGTTTT\", 1)\nKmerArray{4, 1, Int64, Vector{Int64}} with size (4,)\n\njulia> kmer_array |> values\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> count_kmers(dna\"AATT\", 2) |> values # 2-mers of AATT\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  0  0  0\n 0  0  0  0\n 1  0  0  1\n\njulia> count_kmers(aa\"AY\", 1) |> values\n20-element Vector{Int64}:\n 1\n 0\n 0\n ⋮\n 0\n 1\n 0","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main downside of counting K-mers this way is that the arrays grow exponentially with respect to K. The 31-mer array of a DNA sequence would have a length of 4^31 = 4611686018427387904, which is equivalent to four exbibytes of memory, if the values are stored with 8-bit integers — which is just not feasible, really. Not only does allocating a lot of memory take up a lot of memory, but it can also take a substantial amount of time! This method of counting K-mers therefore works best for lower K-values.","category":"page"}]
}
